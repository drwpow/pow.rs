---
import { Code } from 'astro/components';
import PostLayout from '../../layouts/post.astro';

export const frontmatter = {
  title: 'Why aren’t you using Vitest for testing yet?',
  description: 'Throw away whatever you’re using already and use this for testing.',
  date: '2022-10-19',
  tags: ['dev'],
};
---

<PostLayout content={frontmatter}>
  <p>
    <a href="https://vitest.dev/" target="_blank" rel="noopener noreferrer">Vitest</a> is the hottest thing to happen in testing since … <em>ever</em>. And that’s not an exaggeration! It’s truly a milestone in web dev that no one could have
    predicted. I’ll admit that when I heard Vite could be used as a test runner I had a knee-jerk <a href="https://www.youtube.com/watch?v=O7oD_oX-Gio" target="_blank" rel="noopener noreferrer"
      ><i>you-got-peanut-butter-in-my-chocolate</i>
    </a> reaction where it felt like two things got combined by accident. But the more I’ve used it and thought about it, the more I’ve realized the combination is absolutely perfect for each other and it’s been a crucial missing piece in the
    webdev workflow that can’t be overstated.
  </p>

  <p>And, <em>yes</em>, you should be using Vitest.</p>

  <h2>Why Vitest is historically significant</h2>

  <p>
    As one of the core maintainers of <a href="https://github.com/FredKSchott/snowpack" target="_blank">Snowpack</a> (it was real hot before Vite came along) and one of the creators of <a
      href="https://github.com/withastro/astro"
      target="_blank"
      rel="noopener noreferrer">Astro</a
    >, I can say with experience that dealing with CommonJS vs ESM interop code is <em>hard</em>. And until Vite, the defacto way of managing it was to avoid it. Mainly by way of backporting everything into legacy CommonJS. Which, in the
    year of our Lord 2022—<a href="/blog/the-state-of-es-modules-in-2020">seven years after ESM has been standardized</a>—Jest is still transpiling modern ESM code back to legacy CommonJS with no end in sight. And when it comes to testing,
    <strong>it makes no sense to execute your code in a different language from the one it was written in</strong>. And yet that’s what Jest has been doing this entire time.
  </p>

  <p>
    So point one in Vitest’s favor over Jest: <strong>It executes your code as it was written</strong>.
  </p>

  <p>
    But it gets even better: not only is your test runner <em>closer</em> to your production build than Jest—which is significant on its own. <strong>Your test runner actually <em>is</em> your production build.</strong> And this is something
    we’ve never seen before (not without running true, heavy E2E tests, that is).
  </p>

  <p>Gone are the days of fighting with Jest, spending time setting up your env vars, build plugins, configuration settings, … And after everything is done, still having to mock some of your modules that Jest just won’t run.</p>

  <p>
    Vitest extending Vite means you don’t have to reconfigure env vars, plugins, settings, and all the implementation nuances of your production build. You reuse everything quite literally. And as your production app changes, so does your
    test runner! It’s this subtle brilliance that makes me wonder why no one has thought of this before. Vitest feels like a critical step toward a <a href="https://rome.tools/" target="_blank" rel="noopener noreferrer">unified toolchain</a
    > for JavaScript that’s available today. And that’s point two in Vitest’s favor: <strong>you use your <em>exact</em> production build config in your tests—with no setup and no maintenance</strong>.
  </p>

  <p>
    <i>But wait, there’s more!</i> Because Vitest is built on Vite’s powerful transpilation engine, you can also import <strong>any type of file in your tests</strong>. Anything your production app supports, so does your test runner. No
    more mocking critical parts of your app just because your test runner doesn’t understand it—no setup needed. So point three for Vitest: <strong>you can use any language, any tool, without any additional setup</strong>.
  </p>

  <p>
    The last stroke of brilliance Vitest had was <strong>matching Jest’s API</strong>. It was quite literally designed from the ground-up to replace Jest, which is something all other test runners since Jest have struggled with. Love or
    hate Jest, having used (almost) every Node.js test runner under the sun, there’s still a level of maturity to Jest that makes it difficult to replace in real-world test suites. So the fourth point in Vitest’s favor: <strong
      >you only get benefits switching from Jest with nothing asked for in return</strong
    >.
  </p>

  <p>So though it may seem counterintuitive or overcomplicated to use your production build tool for testing, nothing could be further from the truth: <i>Vitest is the simplest testing setup we’ve ever had.</i></p>

  <h2>Vitest is the future of testing</h2>

  <p>
    On any team I’ve been on in recent memory, I’ve had the <strike>misfortune</strike>
    <i>pleasure</i> of setting up testing because of my knowledge and experience. And that’s come hard-earned by wrestling with Jest, Mocha, and every other attempted replacement for longer than most people have. And it’s Vitest’s holistic approach
    to loading and running files that has made me such a believer that Vitest is the future of testing.
  </p>

  <p>I think Vite has now become the gold standard in build tooling for JS, and is now an essential part of every web stack. And Vitest is part of that.</p>

  <p>
    And if Vite is ever replaced as the go-to build tool, then Vitest should also be replaced with a new runner built on the build tool. Because that hard-coupling of builder and test runner is such a good paradigm shift for the web
    platform I hope we all opt in to and never look back.
  </p>
</PostLayout>
